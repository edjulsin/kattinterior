create schema if not exists "private";

create type "public"."app_permission" as enum ('projects.update', 'projects.delete', 'contacts.select', 'users.select', 'roles.select', 'roles.update', 'invites.select', 'storage.projects.insert', 'storage.projects.delete', 'storage.projects.select');

create type "public"."app_role" as enum ('admin', 'contributor', 'owner');


  create table "public"."contacts" (
    "id" bigint generated by default as identity not null,
    "email" text not null,
    "name" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."contacts" enable row level security;


  create table "public"."invites" (
    "invited_by" uuid not null default auth.uid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "id" bigint generated by default as identity not null,
    "email" character varying not null
      );


alter table "public"."invites" enable row level security;


  create table "public"."permissions" (
    "id" bigint generated by default as identity not null,
    "role" public.app_role not null default 'contributor'::public.app_role,
    "permission" public.app_permission
      );


alter table "public"."permissions" enable row level security;


  create table "public"."projects" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "published_at" timestamp with time zone not null default now(),
    "featured" boolean not null default false,
    "published" boolean not null default false,
    "category" text not null default ''::text,
    "name" text not null default ''::text,
    "location" text not null default ''::text,
    "story" text not null default ''::text,
    "tagline" text not null default ''::text,
    "slug" text not null default ''::text,
    "title" text not null default ''::text,
    "description" text not null default ''::text,
    "template" jsonb,
    "assets" jsonb,
    "created_by" uuid default auth.uid()
      );


alter table "public"."projects" enable row level security;


  create table "public"."roles" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "role" public.app_role not null default 'contributor'::public.app_role
      );


alter table "public"."roles" enable row level security;


  create table "public"."users" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "avatar" jsonb,
    "name" character varying,
    "confirmed" boolean not null default false
      );


alter table "public"."users" enable row level security;

CREATE UNIQUE INDEX contacts_email_key ON public.contacts USING btree (email);

CREATE UNIQUE INDEX contacts_pkey ON public.contacts USING btree (id);

CREATE UNIQUE INDEX invites_email_key ON public.invites USING btree (email);

CREATE UNIQUE INDEX invites_pkey ON public.invites USING btree (id);

CREATE UNIQUE INDEX invites_user_id_key ON public.invites USING btree (user_id);

CREATE UNIQUE INDEX permissions_pkey ON public.permissions USING btree (id);

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

CREATE UNIQUE INDEX projects_slug_key ON public.projects USING btree (slug);

CREATE UNIQUE INDEX roles_pkey ON public.roles USING btree (id);

CREATE UNIQUE INDEX roles_user_id_key ON public.roles USING btree (user_id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

alter table "public"."contacts" add constraint "contacts_pkey" PRIMARY KEY using index "contacts_pkey";

alter table "public"."invites" add constraint "invites_pkey" PRIMARY KEY using index "invites_pkey";

alter table "public"."permissions" add constraint "permissions_pkey" PRIMARY KEY using index "permissions_pkey";

alter table "public"."projects" add constraint "projects_pkey" PRIMARY KEY using index "projects_pkey";

alter table "public"."roles" add constraint "roles_pkey" PRIMARY KEY using index "roles_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."contacts" add constraint "contacts_email_key" UNIQUE using index "contacts_email_key";

alter table "public"."invites" add constraint "invites_email_key" UNIQUE using index "invites_email_key";

alter table "public"."invites" add constraint "invites_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."invites" validate constraint "invites_user_id_fkey";

alter table "public"."invites" add constraint "invites_user_id_key" UNIQUE using index "invites_user_id_key";

alter table "public"."projects" add constraint "projects_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."projects" validate constraint "projects_created_by_fkey";

alter table "public"."projects" add constraint "projects_slug_key" UNIQUE using index "projects_slug_key";

alter table "public"."roles" add constraint "roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."roles" validate constraint "roles_user_id_fkey";

alter table "public"."roles" add constraint "roles_user_id_key" UNIQUE using index "roles_user_id_key";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION private.authorize(requested_permission public.app_permission)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$declare
  bind_permissions int;
begin
  select count(*)
  from public.permissions
  where permissions.permission = authorize.requested_permission
    and permissions.role = (auth.jwt() -> 'app_metadata' ->> 'user_role')::public.app_role
  into bind_permissions;
  
  return bind_permissions > 0;
end;$function$
;

CREATE OR REPLACE FUNCTION private.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$begin
  insert into public.users (id) values (new.id);
  insert into public.roles (user_id) values (new.id);
  return new;
end;$function$
;

grant delete on table "public"."contacts" to "anon";

grant insert on table "public"."contacts" to "anon";

grant references on table "public"."contacts" to "anon";

grant select on table "public"."contacts" to "anon";

grant trigger on table "public"."contacts" to "anon";

grant truncate on table "public"."contacts" to "anon";

grant update on table "public"."contacts" to "anon";

grant delete on table "public"."contacts" to "authenticated";

grant insert on table "public"."contacts" to "authenticated";

grant references on table "public"."contacts" to "authenticated";

grant select on table "public"."contacts" to "authenticated";

grant trigger on table "public"."contacts" to "authenticated";

grant truncate on table "public"."contacts" to "authenticated";

grant update on table "public"."contacts" to "authenticated";

grant delete on table "public"."contacts" to "postgres";

grant insert on table "public"."contacts" to "postgres";

grant references on table "public"."contacts" to "postgres";

grant select on table "public"."contacts" to "postgres";

grant trigger on table "public"."contacts" to "postgres";

grant truncate on table "public"."contacts" to "postgres";

grant update on table "public"."contacts" to "postgres";

grant delete on table "public"."contacts" to "service_role";

grant insert on table "public"."contacts" to "service_role";

grant references on table "public"."contacts" to "service_role";

grant select on table "public"."contacts" to "service_role";

grant trigger on table "public"."contacts" to "service_role";

grant truncate on table "public"."contacts" to "service_role";

grant update on table "public"."contacts" to "service_role";

grant delete on table "public"."invites" to "anon";

grant insert on table "public"."invites" to "anon";

grant references on table "public"."invites" to "anon";

grant select on table "public"."invites" to "anon";

grant trigger on table "public"."invites" to "anon";

grant truncate on table "public"."invites" to "anon";

grant update on table "public"."invites" to "anon";

grant delete on table "public"."invites" to "authenticated";

grant insert on table "public"."invites" to "authenticated";

grant references on table "public"."invites" to "authenticated";

grant select on table "public"."invites" to "authenticated";

grant trigger on table "public"."invites" to "authenticated";

grant truncate on table "public"."invites" to "authenticated";

grant update on table "public"."invites" to "authenticated";

grant delete on table "public"."invites" to "postgres";

grant insert on table "public"."invites" to "postgres";

grant references on table "public"."invites" to "postgres";

grant select on table "public"."invites" to "postgres";

grant trigger on table "public"."invites" to "postgres";

grant truncate on table "public"."invites" to "postgres";

grant update on table "public"."invites" to "postgres";

grant delete on table "public"."invites" to "service_role";

grant insert on table "public"."invites" to "service_role";

grant references on table "public"."invites" to "service_role";

grant select on table "public"."invites" to "service_role";

grant trigger on table "public"."invites" to "service_role";

grant truncate on table "public"."invites" to "service_role";

grant update on table "public"."invites" to "service_role";

grant delete on table "public"."permissions" to "anon";

grant insert on table "public"."permissions" to "anon";

grant references on table "public"."permissions" to "anon";

grant select on table "public"."permissions" to "anon";

grant trigger on table "public"."permissions" to "anon";

grant truncate on table "public"."permissions" to "anon";

grant update on table "public"."permissions" to "anon";

grant delete on table "public"."permissions" to "authenticated";

grant insert on table "public"."permissions" to "authenticated";

grant references on table "public"."permissions" to "authenticated";

grant select on table "public"."permissions" to "authenticated";

grant trigger on table "public"."permissions" to "authenticated";

grant truncate on table "public"."permissions" to "authenticated";

grant update on table "public"."permissions" to "authenticated";

grant delete on table "public"."permissions" to "postgres";

grant insert on table "public"."permissions" to "postgres";

grant references on table "public"."permissions" to "postgres";

grant select on table "public"."permissions" to "postgres";

grant trigger on table "public"."permissions" to "postgres";

grant truncate on table "public"."permissions" to "postgres";

grant update on table "public"."permissions" to "postgres";

grant delete on table "public"."permissions" to "service_role";

grant insert on table "public"."permissions" to "service_role";

grant references on table "public"."permissions" to "service_role";

grant select on table "public"."permissions" to "service_role";

grant trigger on table "public"."permissions" to "service_role";

grant truncate on table "public"."permissions" to "service_role";

grant update on table "public"."permissions" to "service_role";

grant delete on table "public"."projects" to "anon";

grant insert on table "public"."projects" to "anon";

grant references on table "public"."projects" to "anon";

grant select on table "public"."projects" to "anon";

grant trigger on table "public"."projects" to "anon";

grant truncate on table "public"."projects" to "anon";

grant update on table "public"."projects" to "anon";

grant delete on table "public"."projects" to "authenticated";

grant insert on table "public"."projects" to "authenticated";

grant references on table "public"."projects" to "authenticated";

grant select on table "public"."projects" to "authenticated";

grant trigger on table "public"."projects" to "authenticated";

grant truncate on table "public"."projects" to "authenticated";

grant update on table "public"."projects" to "authenticated";

grant delete on table "public"."projects" to "postgres";

grant insert on table "public"."projects" to "postgres";

grant references on table "public"."projects" to "postgres";

grant select on table "public"."projects" to "postgres";

grant trigger on table "public"."projects" to "postgres";

grant truncate on table "public"."projects" to "postgres";

grant update on table "public"."projects" to "postgres";

grant delete on table "public"."projects" to "service_role";

grant insert on table "public"."projects" to "service_role";

grant references on table "public"."projects" to "service_role";

grant select on table "public"."projects" to "service_role";

grant trigger on table "public"."projects" to "service_role";

grant truncate on table "public"."projects" to "service_role";

grant update on table "public"."projects" to "service_role";

grant delete on table "public"."roles" to "authenticated";

grant insert on table "public"."roles" to "authenticated";

grant references on table "public"."roles" to "authenticated";

grant select on table "public"."roles" to "authenticated";

grant trigger on table "public"."roles" to "authenticated";

grant truncate on table "public"."roles" to "authenticated";

grant update on table "public"."roles" to "authenticated";

grant delete on table "public"."roles" to "postgres";

grant insert on table "public"."roles" to "postgres";

grant references on table "public"."roles" to "postgres";

grant select on table "public"."roles" to "postgres";

grant trigger on table "public"."roles" to "postgres";

grant truncate on table "public"."roles" to "postgres";

grant update on table "public"."roles" to "postgres";

grant delete on table "public"."roles" to "service_role";

grant insert on table "public"."roles" to "service_role";

grant references on table "public"."roles" to "service_role";

grant select on table "public"."roles" to "service_role";

grant trigger on table "public"."roles" to "service_role";

grant truncate on table "public"."roles" to "service_role";

grant update on table "public"."roles" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "postgres";

grant insert on table "public"."users" to "postgres";

grant references on table "public"."users" to "postgres";

grant select on table "public"."users" to "postgres";

grant trigger on table "public"."users" to "postgres";

grant truncate on table "public"."users" to "postgres";

grant update on table "public"."users" to "postgres";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";


  create policy "select access for admin & owner"
  on "public"."contacts"
  as permissive
  for select
  to authenticated
using (private.authorize('contacts.select'::public.app_permission));



  create policy "select access for self & admin"
  on "public"."invites"
  as permissive
  for select
  to authenticated
using (((( SELECT auth.uid() AS uid) = invited_by) OR private.authorize('invites.select'::public.app_permission)));



  create policy "delete access for admin & owner"
  on "public"."projects"
  as permissive
  for delete
  to authenticated
using (private.authorize('projects.delete'::public.app_permission));



  create policy "insert access for self"
  on "public"."projects"
  as permissive
  for insert
  to authenticated
with check ((( SELECT auth.uid() AS uid) = created_by));



  create policy "select access for auth & anon"
  on "public"."projects"
  as permissive
  for select
  to anon, authenticated
using (true);



  create policy "update access for self, admin, & owner"
  on "public"."projects"
  as permissive
  for update
  to authenticated
using (((( SELECT auth.uid() AS uid) = created_by) OR private.authorize('projects.update'::public.app_permission)))
with check (((( SELECT auth.uid() AS uid) = created_by) OR private.authorize('projects.update'::public.app_permission)));



  create policy "select access for self, owner, and admin"
  on "public"."roles"
  as permissive
  for select
  to authenticated
using (((( SELECT auth.uid() AS uid) = user_id) OR private.authorize('roles.select'::public.app_permission) OR (EXISTS ( SELECT 1
   FROM public.invites
  WHERE ((invites.user_id = roles.user_id) AND (invites.invited_by = ( SELECT auth.uid() AS uid)))))));



  create policy "select access for supabase_auth_admin"
  on "public"."roles"
  as permissive
  for select
  to supabase_auth_admin
using (true);



  create policy "update access for admin"
  on "public"."roles"
  as permissive
  for update
  to authenticated
using (private.authorize('roles.update'::public.app_permission))
with check (private.authorize('roles.update'::public.app_permission));



  create policy "select access for admin, owner, and self"
  on "public"."users"
  as permissive
  for select
  to authenticated
using (((( SELECT auth.uid() AS uid) = id) OR private.authorize('users.select'::public.app_permission) OR (EXISTS ( SELECT 1
   FROM public.invites
  WHERE ((invites.user_id = users.id) AND (invites.invited_by = ( SELECT auth.uid() AS uid)))))));



  create policy "update acccess for self"
  on "public"."users"
  as permissive
  for update
  to authenticated
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION private.handle_new_user();


  create policy "full access for self 1oj01fe_0"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'avatars'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "full access for self 1oj01fe_1"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'avatars'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "full access for self 1oj01fe_2"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'avatars'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "full access for self 1oj01fe_3"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'avatars'::text) AND (( SELECT (auth.uid())::text AS uid) = (storage.foldername(name))[1])));



  create policy "sel, ins, del access for admin, self, & owner 1iiiika_0"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'projects'::text) AND (EXISTS ( SELECT 1
   FROM public.projects
  WHERE (((projects.id)::text = (storage.foldername(objects.name))[1]) AND (((projects.created_by)::text = ( SELECT (auth.uid())::text AS uid)) OR private.authorize('storage.projects.select'::public.app_permission)))))));



  create policy "sel, ins, del access for admin, self, & owner 1iiiika_1"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'projects'::text) AND (EXISTS ( SELECT 1
   FROM public.projects
  WHERE (((projects.id)::text = (storage.foldername(objects.name))[1]) AND (((projects.created_by)::text = ( SELECT (auth.uid())::text AS uid)) OR private.authorize('storage.projects.insert'::public.app_permission)))))));



  create policy "sel, ins, del access for admin, self, & owner 1iiiika_2"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'projects'::text) AND (EXISTS ( SELECT 1
   FROM public.projects
  WHERE (((projects.id)::text = (storage.foldername(objects.name))[1]) AND (((projects.created_by)::text = ( SELECT (auth.uid())::text AS uid)) OR private.authorize('storage.projects.delete'::public.app_permission)))))));




